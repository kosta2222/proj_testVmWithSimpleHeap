* Переопределения    
typedef unsigned char u1;    
typedef uint32_t u4;    
* Что нового в переменных ВМ    
Сделал такие структуры    
typedef struct {    
        long heapPtr;    
        int type;    
    
    } Object;    
    
    typedef struct {    
        float floatValue;    
        u4 intValue;    
        Object object;    
    } Variable;    
    
и сделал такой операндовый стек:    
Variable stack[DEFAULT_STACK_SIZE]    

    
* Как попытался сделать кучу в стиле С    
Обьявил глобальные переменные    
Variable * m_objectMap[100];    
u4 m_nNextObjectID = 0;    
Первая строка - карта где хочу хранить массив указателей на    
структуру Variable, эту структуру т.е. ее поле floatValue я 
собираюсь использовать для постраения массивов для чисел и хранить указатель
на такой массив хранить в m_objectMap.
** Как я делал функцию создания массивы и отпечатки "карты",в последней ERROR!!!
Принимает условный тип что это массив и количество элементов со стека,
в исходном коде задается так
($ (newarray(6)) соответственно появилась ветка в исполнителе 
case NEWARRAY она выглядит так:
 case NEWARRAY:
          {
            vm->stack[++sp].object = createNewArray (1, (int) vm->stack[sp].floatValue);
          }
 
Object
createNewArray (u4 type, u4 count)
{
  Object object;
  object.heapPtr = NULL;
  object.type = 0;

  // Создаем массив
  Variable *obj = (Variable*) malloc (sizeof (Variable)*(count + 1));

  // Добавляем обьект в "карту"
  if (obj)
    {
      memset (obj, 0, sizeof (Variable) * (count + 1));
      object.heapPtr = m_nNextObjectID++;
      obj[0].intValue = type;
      m_objectMap[object.heapPtr] = obj;
    }


  return object;
}

void
dumpHeap ()
{
  // обработать "карту"
  for (int i = 0; i < 10; i++) // возьмем 10 указателей
    {
      printf ("key %d=>\n", i);

      Variable* ptrElem = m_objectMap[i]; // получаем указатель на массив из "карты"
      for (int i = 0; i < 4; i++) // Надо отпечатать этот массив
        {
          printf ("%f:", ptrElem[i].floatValue);// Вот здсь ЗАВИСАЕТ-ОШИБКА
        }

    }

}

*** Отладка функции dumpHeap в vm.cpp
Breakpoint 1 at 0x401515: file d:/NetBeansCppProjects/proj_testVmWithSimpleHeap/
vm.cpp, line 143.
(gdb) run
Starting program: D:\NetBeansCppProjects\proj_testVmWithSimpleHeap\dist\Debug\Mi
nGW-Windows\proj_testvmwithsimpleheap.exe
[New Thread 1480.0xd00]
size of whole byte-code 4
0000: iconst     5.000000number of byte-code:12
stack=[ 5.000000 ]
Heap:

Breakpoint 1, dumpHeap ()
    at d:/NetBeansCppProjects/proj_testVmWithSimpleHeap/vm.cpp:143
143       for (int i = 0; i < 10; i++) // Р?Р?Р·С?Р?РчР? 10 С?РєР°Р·Р°С'РчР>РчР№
(gdb) p ptrElem
$1 = (Variable *) 0x0
D:\NetBeansCppProjects\proj_testVmWithSimpleHeap\dist\Debug\MinGW-Windows(gdb) p ptrElem .floatValue
Cannot access memory at address 0x0
*** (Попытка) Отладка создаеся ли массив в куче
Breakpoint 3, main ()
    at d:/NetBeansCppProjects/proj_testVmWithSimpleHeap/vm.cpp:502
502       VM *vm = vm_create (opcodeCharBuffer, sizeof (opcodeCharBuffer), 0);
(gdb) p opcodeCharBuffer
$1 = (u1 *) 0x5f1888 "\f"
(gdb) n
503       vm_exec (vm, 0, true, 0);
(gdb) s
vm_exec (vm=0x5f38f8, startip=0, trace=true, returnPrintOpFromLocals_flag=0)
    at d:/NetBeansCppProjects/proj_testVmWithSimpleHeap/vm.cpp:175
175       float a = 0;
(gdb) n
176       float b = 0;
(gdb) n
177       int addr = 0;
(gdb) n
178       int offset = 0;
(gdb) n
180       ip = startip;
(gdb) n
181       sp = -1;
(gdb) n
182       callsp = -1;
(gdb) n
195       u4 opcode = vm->code[ip];
(gdb) n
196       while (opcode != HALT)
(gdb) p opcode
$2 = 12
(gdb) n
198           if (trace)
(gdb) n
200               vm_print_instr (vm->code, ip);
(gdb) n
0000: iconst     5.000000203          printf ("number of byte-code:%d\n", opcode
);
(gdb) n
number of byte-code:12
204           ip++;
(gdb)
205           switch (opcode)
(gdb) n
269               vm->stack[++sp].floatValue = *((float*) &vm->code[ip]);
(gdb) n
271               ip += 3;
(gdb) n
272               ip++;
(gdb) n
273               break;
(gdb) n
375           if (trace) vm_print_stack (vm->stack, sp);
(gdb) n
stack=[ 5.000000 ]
376           opcode = vm->code[ip];
(gdb) n
377           printf ("Heap:\n");
(gdb) p opcode
$3 = 25
(gdb) n
Heap:
378           dumpHeap ();
**** Не выполнила опкод NEWARRAY из исходногfо кода!
***** Решение:NEARRAY после добавки break выполняется=>куча с массивом отпечатывается !
После ($(newarray (5)) вывод:
size of whole byte-code 4
0000: iconst     5.000000number of byte-code:12
stack=[ 5.000000 ]
0005:  NEWARRAY            number of byte-code:25
stack=[ 5.000000 0.000000 ]
Data memory:
Heap:
key 0 => This type is 10.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, -1624034898851750000000.000000, 0.000000, 0.000000, 0.000000,
key 1 => key 2 => key 3 => key 4 => key 5 => key 6 => key 7 => key 8 => key 9 =>
***** 0 элемента обьекта будет обозначать его тип т.е. массив, взял 1 - почемуто отпечатал 10.000000
В  ветка attempt-to-add-Array-Heap-support коммит  heap with array works but does not show it s type correctly

